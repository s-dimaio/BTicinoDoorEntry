const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const config = require('../config/config');

/**
 * BticinoApiClient
 * Lightweight wrapper for common BTicino / Legrand developer API endpoints.
 * It relies on an injected {@link BticinoAuthentication} instance to obtain and refresh tokens.
 * The client lazily calls `auth.authenticate()` if no tokens are present.
 *
 * Typical usage:
 * @example
 * const BticinoAuthentication = require('./BticinoAuthentication');
 * const BticinoApiClient = require('./BticinoApiClient');
 * const auth = new BticinoAuthentication({ debug: true });
 * const api = new BticinoApiClient(auth);
 * const plants = await api.getPlants();
 * console.log('Plants:', plants);
 */
class BticinoApiClient {
  /**
   * Construct a new API client.
   * @param {BticinoAuthentication} authInstance Auth orchestrator instance (must expose `authenticate()` and `currentTokens`)
   * @param {Object} [options]
   * @param {string} [options.subscriptionKey] Ocp-Apim-Subscription-Key used by the mobile app (defaults to `lib/config/config.js`)
   * @param {number} [options.timeoutMs=30000] Axios request timeout in ms
   * @param {boolean} [options.debug=false] Enable debug logging
   * @example
   * const api = new BticinoApiClient(auth, { timeoutMs: 45000 });
   */
  constructor(authInstance, options = {}) {
    if (!authInstance) throw new Error('authInstance required');
    this.auth = authInstance;
    // Allow passing sipClientId and an optional callback to receive it when generated
    // options.sipClientId: explicit sip client id to use
    // options.onSipClientId: function(sipClientId) called only when the id is generated by the client
    // Merge options first so callers can override subscriptionKey via options
    this.opts = { timeoutMs: 30000, debug: false, ...options };
    // Resolve subscriptionKey: prefer explicit option, then centralized config
    this.opts.subscriptionKey = this.opts.subscriptionKey || (config && config.SUBSCRIPTION_KEY);

    // Fail fast if no subscription key is configured
    if (!this.opts.subscriptionKey) {
      throw new Error('Subscription key required: set `SUBSCRIPTION_KEY` in lib/config/config.js or pass `options.subscriptionKey`');
    }
    this.base = 'https://api.developer.legrand.com';
    this._debug = !!this.opts.debug;

    // SIP client id: prefer options.sipClientId, then auth.sipClientId, otherwise generate a new one.
    const sipFromOptions = this.opts.sipClientId ? String(this.opts.sipClientId) : null;
    const sipFromAuth = (this.auth && this.auth.sipClientId) ? String(this.auth.sipClientId) : null;
    if (sipFromOptions) {
      this.sipClientId = sipFromOptions;
      // Use the conditional logger (enabled when debug is true)
      this._log && this._log('Using provided sipClientId (options):', this.sipClientId);
    } else if (sipFromAuth) {
      this.sipClientId = sipFromAuth;
      this._log && this._log('Using sipClientId from auth instance:', this.sipClientId);
    } else {
      this.sipClientId = this._generateSipClientId();
      // Notify caller that an id was generated
      this._log && this._log('Generated sipClientId:', this.sipClientId);
      // Note: invocation of `options.onSipClientId` has been removed. Consumers
      // can obtain the id with `api.getSipClientId()` or observe the
      // `deviceRegistered` event emitted by the registration flow which
      // contains the final `sipClientId` value.
    }
  }

  /** Return the sip client id in use */
  getSipClientId() { return this.sipClientId; }

  /**
   * Return the SIP client id currently in use.
   * @returns {string} SIP client identifier (numeric string)
   */

  /**
   * Conditional logger. Logs only when debug mode is enabled.
   * @param {...*} args Values to log
   */
  /**
   * Conditional debug logger for the API client (internal).
   * @private
   */
  _log(...args) { if (this._debug) console.log('[ApiClient]', ...args); }

  /**
   * Conditional debug warn logger for the API client (internal).
   * @private
   */
  _warn(...args) { if (this._debug) console.warn('[ApiClient]', ...args); }

  /**
   * Conditional debug error logger for the API client (internal).
   * @private
   */
  _error(...args) { console.error('[ApiClient]', ...args); }

  /**
   * Generate a SIP client identifier that mimics values produced by mobile apps.
   * Produces a numeric string with length between 21 and 23 digits.
   * @private
   * @returns {string} Numeric SIP client id
   */
  _generateSipClientId() {
    // Generate a random numeric string 21-23 digits long (as Android/iOS do)
    const length = 21 + Math.floor(Math.random() * 3); // 21, 22 or 23 digits
    let sipClientId = '';

    // First digit must not be 0
    sipClientId += Math.floor(Math.random() * 9) + 1;

    // Remaining digits
    for (let i = 1; i < length; i++) {
      sipClientId += Math.floor(Math.random() * 10);
    }

    return sipClientId;
  }

  /**
   * Ensure we have a usable access token (interactive login only once).
   * Does not force refresh; scheduled refresh handled by auth instance.
   * @private
   * @returns {Promise<string>} Access token string
   */
  async _getAccessToken() {
    if (!this.auth.currentTokens) {
      const { tokens } = await this.auth.authenticate();
      if (!tokens?.b2cAccessToken) throw new Error('No access token after authentication');
    }
    return this.auth.currentTokens.b2cAccessToken;
  }

  /**
   * Build standard headers for API requests.
   * @private
   * @param {Object} [extra] Additional headers to merge
   * @returns {Object} Headers object
   */
  _headers(extra = {}) {
    const headers = {
      Authorization: `Bearer ${this.auth.currentTokens?.b2cAccessToken || ''}`,
      'Ocp-Apim-Subscription-Key': this.opts.subscriptionKey,
      UserToken: this.auth.currentTokens?.b2cAccessToken || '',
      Accept: 'application/json',
      'Content-Type': 'application/json',
      'User-Agent': 'bticino-api-client/1.0',
      ...extra
    };

    return headers;
  }

  /**
   * Internal GET helper (axios) adding auth headers & timeout.
   * @private
   * @param {string} url Absolute endpoint URL
   * @returns {Promise<any>} Parsed JSON body
   */
  async _get(url) {
    await this._getAccessToken(); // ensure tokens are ready
    const res = await axios.get(url, { headers: this._headers(), timeout: this.opts.timeoutMs });
    return res.data;
  }

  /**
   * Internal POST helper (axios) adding auth headers & timeout.
   * @private
   * @param {string} url Absolute endpoint URL
   * @param {Object} data Request body (will be JSON stringified)
   * @returns {Promise<any>} Parsed JSON body
   */
  async _post(url, data) {
    await this._getAccessToken(); // ensure tokens are ready
    try {
      const res = await axios.post(url, data, { headers: this._headers(), timeout: this.opts.timeoutMs });
      return res.data;
    } catch (error) {
      // Enhanced error logging for debugging
      if (error.response) {
        const errMsg = `Request failed with status code ${error.response.status}`;
        if (this.opts && this.opts.debug) {
          console.error('[ApiClient] POST Error Details:');
          console.error('  URL:', url);
          console.error('  Status:', error.response.status);
          console.error('  Status Text:', error.response.statusText);
          console.error('  Response Data:', JSON.stringify(error.response.data, null, 2));
          console.error('  Request Data:', JSON.stringify(data, null, 2));
        }
        throw new Error(errMsg);
      }
      throw error;
    }
  }

  // --- Public API wrappers ---
  /**
   * Get current user consents / privacy settings.
   * @returns {Promise<Object>} Consents object
   * @example
   * const consents = await api.getConsents();
   */
  async getConsents() { return this._get(`${this.base}/users/api/v3.0/users/consents/account`); }

  /**
   * List all registered modules (devices) visible to the user.
   * If `plantId` is provided the method returns only modules belonging to that plant.
   * @param {string} [plantId] Optional plant UUID to filter modules
   * @returns {Promise<Array|Object>} If no `plantId` provided, returns an Array of module objects
   *                                   If `plantId` provided, returns an Array of modules for that plant
   * @example
   * const modules = await api.getModules();
   * const plantModules = await api.getModules('e914fxx-xxxx-xxxx-xxxx-76febdd3xxx');
   */
  async getModules(plantId) {
    const all = await this._get(`${this.base}/servicecatalog/api/v3.0/modules`);
    if (!plantId) return all;
    if (!Array.isArray(all)) return [];
    return all.filter(m => m && (m.plantId === plantId || m.plant_id === plantId));
  }

  /**
   * Find the module id for the gateway device in a plant.
   * Uses `getModules(plantId)` to list modules and returns the `id` of the
   * first module whose `device` attribute equals 'gateway'.
   * @param {string} plantId Plant UUID to search modules for
   * @returns {Promise<string|null>} Module id of the gateway or null if not found
   */
  async getGatewayModuleId(plantId) {
    if (!plantId) throw new Error('plantId is required');
    const modules = await this.getModules(plantId);
    if (!Array.isArray(modules)) return null;
    const gw = modules.find(m => m && String(m.device) === 'gateway');
    if (!gw) return null;
    return gw.id || gw.entityId || null;
  }

  /**
   * List user plants (installations / sites).
   * @returns {Promise<Array>} Array of plant objects
   * @example
   * const plants = await api.getPlants();
   */
  async getPlants() { return this._get(`${this.base}/servicecatalog/api/v3.0/plants`); }

  /**
   * Retrieve detailed information for a single plant.
   * @param {string} plantId UUID of the plant
   * @returns {Promise<Object>} Plant detail
   * @example
   * const plant = await api.getPlant('<plant-id>');
   */
  async getPlant(plantId) { return this._get(`${this.base}/servicecatalog/api/v3.0/plants/${plantId}`); }

  /**
   * Retrieve detailed information for a single module.
   * @param {string} moduleId UUID of the module
   * @returns {Promise<Object>} Module detail
   * @example
   * const module = await api.getModule('<module-id>');
   */
  async getModule(moduleId) { return this._get(`${this.base}/servicecatalog/api/v3.0/modules/${moduleId}`); }

  /**
   * Get SIP accounts for a specific device (gateway).
   * Returns all SIP credentials registered for the device, including passwords.
   * @param {string} gatewayId UUID of the BTicino gateway (NDB module)
   * @returns {Promise<Array>} Array of SIP account objects with sipPassword, sipUri, username, etc.
   * @example
   * const sipAccounts = await api.getSipAccounts('318xxxx-xxxx-xxx-xx-161xxxxba4xxx2');
   * // Returns array with: sipPassword, sipUri, clientId, username, userOid
   */
  async getSipAccounts(gatewayId) {
    return this._get(`${this.base}/vde/sip/v1.0/devices/${gatewayId}/sipaccounts`);
  }

  /**
   * Get SIP credentials for current user on a specific device (gateway).
   * Filters sipAccounts to return only the account matching current user's OID.
   * @param {string} gatewayId UUID of the BTicino gateway
   * @returns {Promise<Object|null>} SIP account object for current user, or null if not found
   * @example
   * const mySipAccount = await api.getCurrentSipAccount('31xxxx8xb...');
   * console.log('My SIP password:', mySipAccount.sipPassword);
   */
  async getCurrentSipAccount(gatewayId) {
    const accounts = await this.getSipAccounts(gatewayId);
    if (!Array.isArray(accounts) || accounts.length === 0) return null;

    // Prefer matching by clientId (sipClientId) when available.
    // The library's sipClientId corresponds to the account.clientId field returned by the API.
    if (this.sipClientId) {
      const matchByClient = accounts.find(acc => String(acc.clientId).toLowerCase() === String(this.sipClientId).toLowerCase());
      if (matchByClient) return matchByClient;
    }

    // Fallback: derive user OID from the B2C access token and match by userOid
    const token = this.auth.currentTokens?.b2cAccessToken;
    if (!token) return null;
    try {
      const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
      const userOid = payload.oid || payload.sub;
      if (userOid) return accounts.find(acc => acc.userOid === userOid) || null;
    } catch (e) {
      this._log && this._log('Failed decoding access token to extract user OID:', e.message);
    }

    return null;
  }

  /**
   * Register a new SIP account for this device.
   * Creates a new SIP account with unique clientId and receives sipPassword from server.
   * @param {string} gatewayId UUID of the BTicino gateway
   * @param {Object} options Registration options
   * @param {string} options.clientId Unique client identifier (19-25 digit number)
   * @param {string} options.clientName Device name (e.g., "samsung SM-J500FN")
   * @param {string} options.userOid User UUID (from authentication)
   * @returns {Promise<Object>} Created SIP account with sipPassword, sipUri, sipId, etc.
   * @example
   * const sipAccount = await api.registerSipAccount('31xxx4xxb...', {
   *   clientId: '2xxxx43xxx1xx19xxx79',
   *   clientName: 'Node.js Gate Opener',
   *   userOid: 'bexxxx9a-xxx-xxx-xxx-8ax6xxxx5xx'
   * });
   * // Returns: { sipId, sipUri, clientId, clientName, username, userOid, sipPassword, appId }
   */
  async registerSipAccount(gatewayId, options = {}) {
    // Allow caller to omit clientId and userOid: fall back to internal sipClientId
    // and derive userOid from the authenticated token.
    const { clientName = 'Node.js Gate Opener' } = options;

  // clientId: prefer explicit option (options.clientId) for compatibility,
  // fall back to options.sipClientId, otherwise use generated/instance sipClientId
  const sipClientId = options.sipClientId || this.sipClientId;

    // Ensure we have a clientId at this point
    if (!sipClientId) {
      throw new Error('SIP clientId is required for SIP account registration (none provided and no generated sipClientId available)');
    }

    // userOid: prefer explicit option, otherwise attempt to extract from current access token
    let userOid = options.userOid;
    if (!userOid) {
      // Ensure tokens present (this will trigger interactive auth if needed)
      await this._getAccessToken();
      const token = this.auth.currentTokens?.b2cAccessToken;
      if (token) {
        try {
          const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString());
          userOid = payload.oid || payload.sub;
        } catch (e) {
          // ignore parse errors - will be handled below
          this._log && this._log('Failed decoding access token to extract user OID:', e.message);
        }
      }
    }

    if (!userOid) {
      throw new Error('userOid is required for SIP account registration (provide options.userOid or ensure authenticated token includes oid)');
    }

    // Build sipUri client-side like the real app does: userOid_clientId@gatewayId.bs.iotleg.com
    const sipUri = `${userOid}_${sipClientId}@${gatewayId}.bs.iotleg.com`;

    const requestBody = {
      clientId: sipClientId,
      clientName: clientName,
      sipUri: sipUri
    };

    // Debug logging before POST
    if (this.opts && this.opts.debug) {
      console.log('[ApiClient] registerSipAccount - Request details:');
      console.log('  Gateway ID:', gatewayId);
      console.log('  Client ID:', sipClientId);
      console.log('  Client Name:', clientName);
      console.log('  SIP URI:', sipUri);
      console.log('  Request Body:', JSON.stringify(requestBody, null, 2));
    }

    return this._post(`${this.base}/vde/sip/v1.0/devices/${gatewayId}/sipaccount`, requestBody);
  }

  /**
   * Register device for push notifications.
   * Enables real-time notifications for doorbell, gateway events, etc.
   * @param {string} gatewayId Gateway UUID
   * @param {Object} options Push registration options
   * @param {string} options.fcmToken Firebase Cloud Messaging token (required)
   * @param {string} [options.deviceUniqueId] Device ID (defaults to this.sipClientId)
   * @param {string} [options.platform='android'] Platform (android/ios)
   * @param {string} [options.language='it_IT'] Language code
   * @returns {Promise<Object>} { notificationId: string }
   * @example
   * const result = await api.registerPushNotification(gatewayId, {
   *   fcmToken: 'fCWxxxv99xPm...',
   *   deviceUniqueId: '87xxxx0xxxx8841xxxx80xxx7',
   *   platform: 'android',
   *   language: 'it_IT'
   * });
   * console.log('Notification ID:', result.notificationId);
   */
  async registerPushNotification(gatewayId, options = {}) {
    const {
      fcmToken,
      deviceUniqueId = this.sipClientId,
      platform = 'android',
      language = 'it_IT'
    } = options;

    if (!fcmToken) {
      throw new Error('FCM token is required for push notification registration');
    }

    const requestBody = {
      deviceUniqueId: deviceUniqueId,
      handle: fcmToken,
      platform: platform,
      language: language
    };

    return this._post(`${this.base}/vde/push/v1.0/devices/${gatewayId}/subscription`, requestBody);
  }

  /**
   * Get current push notification subscriptions for a gateway.
   * Returns all registered devices and their notification tags.
   * @param {string} gatewayId Gateway UUID
   * @returns {Promise<Array>} Array of push subscriptions with tags (IP_CHANGE, TOPOLOGY_CHANGE, DELETE_GW, etc.)
   * @example
   * const subscriptions = await api.getPushSubscriptions(gatewayId);
   * console.log('Active subscriptions:', subscriptions);
   */
  async getPushSubscriptions(gatewayId) {
    return this._get(`${this.base}/vde/push/v1.0/devices/${gatewayId}/subscription`);
  }

  /**
   * Get CA certificates (root certificates) for TLS authentication.
   * @returns {Promise<Object>} CA certificates information
   * @example
   * const caCerts = await api.getCACertificates();
   */
  async getCACertificates() {
    return this._get(`${this.base}/certificate/api/v1.0/ca/information/CACerts`);
  }

  /**
   * Provision (or renew) a client certificate for mTLS authentication.
   * Sends a Certificate Signing Request (CSR) to the server and receives back a signed certificate.
   * @param {Object} request Certificate provisioning request
   * @param {string} request.csr Base64-encoded CSR (DER format)
   * @param {Object} request.sender Sender information (plant + system)
   * @param {string} request.template Certificate template (e.g., "sipuser-DIY")
   * @returns {Promise<Object>} Response with signed certificate { receiver, cert }
   * @example
   * const response = await api.provisionClientCertificate({
   *   csr: "MIxxxxCAZcxxxxQAw...",
   *   sender: { addressType: "addressLocation", plant: {...}, system: "information" },
   *   template: "sipuser-DIY"
   * });
   * console.log('Signed certificate:', response.cert);
   */
  async provisionClientCertificate(request) {
    return this._post(`${this.base}/certificate/api/v1.0/ca/information/clientCerts`, request);
  }



  /** Full dump similar to collect script */
  /**
   * Produce an aggregated dump of consents, modules, plants and enriched plant details.
   * Optionally saves to disk (default) in `frida-results/full_bticino_dump.json`.
   * @param {Object} [options]
   * @param {boolean} [options.save=true] Set to false to skip file save
   * @param {string} [options.file] Custom output file path
   * @returns {Promise<Object>} Dump object { generatedAt, endpoints, plantDetails?, savedTo? }
   * @example
   * const dump = await api.fullDump();
   * console.log('Saved to', dump.savedTo);
   */
  async fullDump(options = {}) {
    const out = { generatedAt: new Date().toISOString(), endpoints: {} };
    try { out.endpoints.consents = { data: await this.getConsents(), success: true }; } catch (e) { out.endpoints.consents = { success: false, error: e.message }; }
    try { out.endpoints.modules = { data: await this.getModules(), success: true }; } catch (e) { out.endpoints.modules = { success: false, error: e.message }; }
    try { out.endpoints.plants = { data: await this.getPlants(), success: true }; } catch (e) { out.endpoints.plants = { success: false, error: e.message }; }

    if (out.endpoints.plants.success && Array.isArray(out.endpoints.plants.data)) {
      out.plantDetails = [];
      for (const p of out.endpoints.plants.data) {
        const id = p.id; if (!id) continue;
        try {
          const detail = await this.getPlant(id);
          const relatedModules = out.endpoints.modules.success && Array.isArray(out.endpoints.modules.data)
            ? out.endpoints.modules.data.filter(m => m.plantId === id)
            : [];
          out.plantDetails.push({ id, detail, modules: relatedModules });
        } catch (e) {
          out.plantDetails.push({ id, error: e.message });
        }
      }
    }

    if (options.save !== false) {
      const file = options.file || path.join(__dirname, 'frida-results', 'full_bticino_dump.json');
      fs.mkdirSync(path.dirname(file), { recursive: true });
      fs.writeFileSync(file, JSON.stringify(out, null, 2), 'utf8');
      out.savedTo = file;
    }
    return out;
  }
}

module.exports = BticinoApiClient;
